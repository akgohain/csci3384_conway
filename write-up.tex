\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amsthm}
% Package for making turing machine diagrams %
\usepackage{tikz}
\usetikzlibrary{chains,fit,shapes}
% Packages for algorithms %
\usepackage{algorithm}
\usepackage{algorithmic}
% Package which has the nice looking empty set symbol (\varnothing)
\usepackage{amssymb}
% Package with the ceiling function
%\usepackage{mathtools}
%\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\usepackage{braket}
\usepackage{amsmath} 
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{comment}
\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\usepackage{bm}

\usepackage{biblatex}
\addbibresource{bibliography.bib}

% Makes table of contents links clickable in pdf readers
\usepackage[colorlinks=true, linkcolor=blue, urlcolor=blue, citecolor=blue, breaklinks=true]{hyperref}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{problem}{Problem}

\theoremstyle{plain}
\newtheorem{example}{Example}[section]
\newtheorem{exercise}{Exercise}[section]

\theoremstyle{plain}
\newtheorem{fact}{Fact}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[section]
\newtheorem{claim}{Claim}[section]

\title{Reachability, Complexity, and the Limits of Conway's Game of Life}
\author{Sebastian Pucher \& Adam Gohain}

\begin{document}

\maketitle

\tableofcontents

\newpage

\section{Introduction: Can Life be Simulated?}
  \textit{    That is the question, isn't it.} For centuries, mathematicians, philosophers, artists, and computer scientists, have spent their lives trying to uncover what it means to truly be alive. Many come together, often crossing their respective disciplines to construct answers to these larger, often existential questions. Even today, humanity has continued to develop complicated technology in hopes of understanding more about life, how it can be studied, or even how it could possibly be synthesized.

\

\textit{What is life?} Back in 1940, John Von Neumann and Stanislaw Ulam set out to prove an answer to this very question. Von Neumann was an American Mathematician whose research focused on self-replicating systems and cellular automata. Alongside his colleague Ulam, who worked together with Von Neumann on the Manhattan Project, they proposed a simple discrete game that replicated life. Their mathematical model consisted of a two-dimensional grid of square cells, where the state of the next generation of cells would depend on the interaction between living cells and their neighbors \cite{Beginning_Life_2006}. They called it \textit{The Universal Constructor} which produced fascinating properties of time and space usage \cite{Freitas_2004}.

\

Not long after their proposal, a British Mathematician known as John Conway extended upon Ulam and Von Neumann’s research to fabricate an instance of their Universal Constructor that better replicated Alan Turing’s “universal computer”. By experimenting with different rules and states between neighboring automata, Conway was able to simplify the model into a game that was only composed of only a few basic rules \cite{Beginning_Life_2006}. [see section (CITE SECTION)]. 

\

Shortly after, in 1970, the \textit{Scientific American} published an article articulating how to play the game which resulted in the greatest number of letters reactions from readers at that time \cite{Izhikevich_Conway_Seth}. In the paper, Conway proposed that no initial pattern could grow without limit, and offered fifty dollars to the first person who could disprove him by the end of the year \cite{math-games}. This catalyzed immense popularity in the game, and set forth the many mathematical discoveries that have now been proven about the game, such as its undecidable nature (see section (CITE SECTION)), and recurring patterns(see section).


\textbf{Going to add a nice image here}

\subsection{The Game}
Similar to how Alan Turing proposed models of computational thinking prior to modern day computers, Conway's Game of Life started as a simple mathematical idea that was “played” on chalkboards and Go boards \cite{Izhikevich_Conway_Seth}. Here are the rules, and how to play: 

\

\textbf{Rules \& Properties: }
\begin{enumerate}

  \item \textbf{Domain: }\\ The automata in the game interact within an \textit{infinite} two-dimensional grid of cells. Every cell has eight neighbors \cite{Izhikevich_Conway_Seth}[figure x]. \label{rule_one}

  \item \textbf{States: }\\ Each automata is represented independently by a single cell which can be either \textit{alive} or \textit{dead}.

  \item \textbf{Initial Configuration: } \\ The beginning set of live or dead cells is determined or "seeded" by the player prior to any evolution.

  \item \textbf{Evolution: } \\ The following rules are applied to all cells simultaneously in fixed time intervals called \textit{generations} \cite{Bontes2019}.

  \item \textbf{Birth: } \\ A new cell is born at generation $t + 1$ when its state is currently \textit{dead} and has exactly three lives neighbors (reproduction) \cite{Bontes2019}.

  \item \textbf{Death: } \\ Any currently living cell will die at generation $t + 1$ if it has less than 2 live neighbors (underpopulation) or more than three live neighbors (overpopulation) \cite{Bontes2019}.

  \item \textbf{Persistence: } \\ Any live cell will persist at $t + 1$ if it has two or three live neighbors at generation $t$ \cite{Izhikevich_Conway_Seth}.
\end{enumerate}

It’s important to note that Conway’s Game of Life is not a game of how we traditionally think of games. There’s no objective, or winning or losing. They’re aren’t even any players – it is known to be a zero player game \cite{Beginning_Life_2006}. As technology advanced, Conway’s Game of Life proved to be well-suited for implementation on computers. Today, the game has been optimized to explore the many unresolved problems and complexity the game poses. 

\subsection{So... What's the Big Deal?}

At first glance, Conway’s game appears to be a simple simulation of life based on just a few rules. However, beneath the surface, the Game of Life hides mathematical complexities that have perplexed many since its proposal way back in 1970. Many of its implications stem from the fact that the game is Turing Complete. Entire self-replicating machines, digital circuits, and unique patterns have been discovered and studied within the properties of the game. In fact, new behaviors are still being uncovered today. 

\ 

\textbf{Proposal}: The purpose of this paper is to both synthesize concrete theoretical mathematics from Complexity Theory into a specific instance of Conway's game of life. More specifically, the paper will be divided into two parts. The first pertaining to the Pattern reachability question, and the second pertaining to Undecidability and Turing Completeness in Conway’s Game of Life. 

\section {Pattern Reachability}

One particular challenge within The Game is the difficulty of predicting and discovering the many different patterns (or "life-forms") that may evolve from one generation to the next. A\textit{ pattern} is defined as a constellation of both live and dead cells that evolve over time \cite{Bontes2019}.

\

Conway's Game of Life is capable of producing patterns that move back and forth, shifting between a finite set of states, patterns that traverse through the grid indefinitely, patterns that trail and leave behind other evolving patterns, and patterns that collide with each other to create other complicated patterns \cite{JG2022conway}.

\

Because of this, there are over a thousand different patterns and life-forms that have been proposed and studied within The Game \cite{Life_Wiki}. Of these many patterns, there are three underlying features that are used to categorize and study them. There are as follows: 

\begin{enumerate}
  \item \textbf{Still Life: } \\ A pattern that remains unchanged from one generation to the next \cite{JG2022conway}. ADD IMAGE
  \item \textbf{Oscillator: } \\ A pattern that cycles between finitely many different configurations. The configuration of the pattern within an individual generations is called a \textbf{phases}. The smallest number of generations needed to repeat the cycle is called the \textbf{period} \cite{JG2022conway}. ADD IMAGE
  \item \textbf{Spaceship: } \\ A pattern that returns to its initial phase after it completes its period, but ends in a different location from where it started. \cite{JG2022conway}
\end{enumerate}

In defining the following life-forms, the next natural question to ask is: \textit{Given an initial starting configuration is it possible to decide if any Still Life, Oscillator, or Spaceship life-form patterns are reachable?}

\

This question can be distilled down into a particular instance of the Pattern Reachability Problem (PREP) \cite{SUTNER199587}. The Pattern Reachability Problem asks: 

 \

 \textit{Question: } Given some instance of Conway's Game of Life, a cellular automata \textbf{A}, a source configuration \textbf{X} and a target configuration \textbf{Y}, \textit{Is there some configuration in the orbit of X that matches Y?} \cite{SUTNER199587}.

\subsection{Definitions, Theorems, and other Important Terminology}
Before proving the proposition that 
\textit {instances of PREP can be decided in nondeterministic polynomial time for two-dimensional finite automata} [see section], lets first formulate the necessary definition, encodings, and terminology we'll need moving forward.

\subsection{Encoding cellular automata in Conway's Game of Life}
To begin, let's represent an instance of a cellular automata in Conway's Game of life as a finite string over an alphabet. The following encoding is inspired by \textit{Sutner's} encoding scheme (see \cite{SUTNER199587}).
\begin{enumerate}
  \item[(a)] Let a CA in \textbf{GoL} be represented as a 4-tuple: \textbf{GoL = } $ <d, k, w, p> $
    \begin{enumerate}
      \item[-] $d$ denotes the dimensions of the finite grid that the automata evolve in. In representing Conway's game of life, our dimensions space will be set to $d = 2$
      \item[-] Every cell has a finite number of states, let's use a finite alphabet $\Sigma_k$, where $\Sigma_k = \{0,1\}$, $1$ indicating that a particular cell in $d$ is \textit{living}, and $0$ indicating that that cell is \textit{dead}. Let $k$ represent this alphabet.
      \item[-] Positive integer $w$ represents the width of a automata's neighborhood in \textbf{GoL}, meaning \textit{the automata's direct neigbors that are involved in updating the cell}. Width is a result of the radius relation: $w = 2*r +1$. Within \textbf{GoL}, our neighborhood rules [rule: \ref{rule_one}], indicate $r = 1$, and $w = 3$.
      \item[-] Let $p : \Sigma^N \to \Sigma$ be the local function which expresses the formal rule mapping (or \textit{local rule}) of the automate in Conway's Game of Life. Our set of rules applies directly to surrounding neighbors, that is$ N := [-r, r]^d \subseteq \mathbb{Z}^d $ 
      \item[-] A map $ X : C \to \Sigma $ takes the set $ C $ of all cells and maps to a state $ k \in \Sigma$. X is the \emph{configuration} of the cellular automaton.
    \end{enumerate}
      \item[(b)] The local map $p$ only updates a given automata based on it's direct neighbors. To extend this to the entire configuration $C$, let's define a global mapping $\rho$ which updates all cell simultaneously. This process will utilize our local mapping rule $p$, and  can be broken into two steps: 
        \begin{enumerate}
          \item[1).] For each cell $c \in C$ create it's local configuration $X_c$, which captures the neighbors around $c$.
          \item[2).] Apply the local rule $p$ to $X_c$ to get the new state at $c$.
        \end{enumerate}
        The global update rule $\rho : \Sigma^C \to \Sigma^C$ is  given by:
        \begin {equation}
        \rho(X)(c) = p(X_c)
        \end {equation}
      \item[(c)] In constructing a \textit{finite} instance of Gol, we must consider how cellular automata behavior on boundaries of the grid.
        \begin{enumerate}
          \item[-] To solve this problem, we will adopt \textit{fixed boundary conditions} \cite{SUTNER199587}. We'll assume that all cells that are not represented in our finite grid will have a fixed state set to $0$. In doing so we can redefine our local mapping $p$ slightly: 
          \item[-] Define $X_c(z)$ to be the state of a cell at postion $c + z$, whenever $c + z \in C$, define its state to be 0, if $c + z$ falls outside the grid.
        \end{enumerate}
      \item[(d)] Let's define the formal definition of a \textit{pattern}. \cite{SUTNER199587}
        \begin{enumerate}
           \item[-] A pattern is a partial configuration, defined as a map $X_0: C_0 \to \Sigma$, where $C_0 \subseteq C$.
    \item[-] We say that a configuration $X$ matches pattern $X_0$ if $X(c) = X_0(c)$ for all $c \in C_0$.
        \end{enumerate}

\item[(e)] The \textit{orbit} of a configuration $X$ is another important definition in regard to our Pattern Reachability Question. The \textit{orbit} is the full set of all intermediary states the system ever passes through starting from $X$. Formally, the orbit is defined as

\begin{equation}
  \text{Orbit of } X = \{ X, \rho(X), \rho^2(X), \rho^3(X), \dots \}
\end{equation}

Another, more useful way we'll be using \textit{orbit} will in regard to some $t$ that is: 

\begin{equation}
\text{Orbit}(X) = \{ \rho^t(X) \mid t \geq 0 \}
\end{equation}

where \( \rho \) is the global update rule and \( t \) ranges over the non-negative integers.
\end{enumerate}
\section{Pattern Reachability}
Now that we have built out the formal definition of \textbf{GoL}, we can treat the Pattern Reachability question as decision problem over finite automata configurations. To prove PERN is NP-Ccomplete, we’ll reduce an instance of SAT to an instance of PERN. To begin, lets now pose PERN more formally as the following:

\textit{Does there exist a time $t \geq 0$ such that the configuration $\rho^t(X)$ contains a given pattern $X_0$?}

\subsection{PERN is in NP:}


\subsubsection*{Problem Definition}
\textbf{Input:}
\begin{itemize}
    \item Finite grid configuration $ C \subset \mathbb{Z}^2 $ where $ |C| $ is the total number cells $n$.
  \item Initial configuration $ X: C \to \Sigma_k = \{0,1\}$ 
    \item Target pattern $ X_0: C_0 \to \Sigma_k $ where \( C_0 \subseteq C \)
    \item Polynomial time bound T(n) = polytime(n) : ensures the certificate is verifiable in polynomial-time.
\end{itemize}

\subsubsection{NP Certificate Based Proof:\cite{SUTNER199587}}
A language is in NP if there exists a polynomial-time TM that can verify PERN's certificate. Let's begin by constructing a certificate:

\begin{enumerate}
    \item \textbf{Certificate:} A tuple $Z = <t, \rho^t(X) >$
      Where: 
      \begin{enumerate}
          \item[(a)] $t$ is a non-negative integer and $t \leq T(n)$
          \item[(a)] $\rho^t(X)$ is the state of the grid at time $t$.
      \end{enumerate}

    \item \textbf{Verification process} Given tuple $Z$:
    \begin{enumerate}
        \item First check to see if $t \leq T(n)$, that is, that $t$ does not exceed polynomial time. This requires $\log(n)$ time.
        \item Next simulate GoL for $t$ steps. Start with configuration $X$, compute $\rho^t(X)$
        \begin{itemize}
            \item Apply our Local update rule: For each cell $c \in C$, compute its next state based on surrounding neighborhood. Each cell is able to apply the local rule in constant time: $O(1)$
            \item To update all $n$ cells in configuration, this takes $n*O(1)$ or $O(n)$ time. This our "per-step" time.
            \item Total compute time for $t$ steps is: $O(t * n) = O(n * polytime(n)) = polytime(n)$ 
        \end{itemize}
        \item Now we must Check to see if resulting configuration matches, that is, we must verify $\rho^t(X)$  matches $X_0$ on $C_0$:
        \begin{itemize}
            \item For each cell $c \in C_0$ check if $\rho^t(X)(c) = X_0(c)$.
            \item This checking must be done for $ |C_0| \leq n $ cells, which takes time: $ O(n) $.
        \end{itemize}
    \end{enumerate}

    \item \textbf{Total verification time: }
      \begin{equation}
        O(\log(n))+O(\text{polytime}(n)*n)+O(n)=\text{polytime}(n).
    \end{equation}

\end{enumerate}



\subsection{Analysis of Still lifes, Oscillators, and Spaceships?}


\section{What can be computed/decided in Conway’s Game of Life?}

\section{REACHES-CONFIGURATION is undecidable}

\printbibliography

\end{document}
